# Practice_2_HP_Aruzhan_Bissimbayeva
Параллельная реализация простых алгоритмов сортировки (пузырьком, выбором, вставкой) на CPU с использованием OpenMP

## Описание

В рамках Practice 2 выполнялись три основных задания, посвящённые алгоритмам сортировки и их параллельной реализации с использованием OpenMP. Основная цель — изучить работу последовательных и параллельных алгоритмов, измерить их производительность и понять особенности распараллеливания на CPU.

### Задание 1: Реализация сортировок без параллелизма
В этом задании были реализованы функции для трёх популярных алгоритмов сортировки:
- **Пузырьком** (Bubble Sort)
- **Выбором** (Selection Sort)
- **Вставками** (Insertion Sort)

Все алгоритмы выполняются последовательно, без использования OpenMP. Для каждого алгоритма создавался массив случайных чисел, производилась сортировка и выводилось время выполнения.

### Задание 2: Параллельная реализация с использованием OpenMP
Во втором задании алгоритмы сортировки были адаптированы для параллельного выполнения:
- Для **пузырька** и **выборки** использовались директивы `#pragma omp parallel for` и `#pragma omp critical` для распараллеливания циклов и защиты общих переменных.
- Сортировка **вставками** оставалась последовательной, так как она имеет сильные зависимости между итерациями, которые невозможно корректно распараллелить.
- Производительность проверялась на массивах разного размера (1000, 10,000 и 100,000 элементов).

### Задание 3: Сравнение производительности
Для сравнения производительности использовалась библиотека `<chrono>`:
- Засекалось время выполнения последовательных и параллельных версий каждого алгоритма.
- Результаты выводились в консоль с указанием времени выполнения в секундах.
- Сравнение позволило увидеть, как распараллеливание влияет на скорость работы алгоритмов и какие алгоритмы выигрывают больше всего при увеличении числа потоков и размера массива.

## Как компилировать и запускать

### Компиляция
Для компиляции используйте g++ с поддержкой OpenMP:

```bash
g++ -fopenmp -O2 -std=c++17 task1.cpp -o task1.exe   # последовательная версия (задание 1)
g++ -fopenmp -O2 -std=c++17 task2.cpp -o task2.exe   # параллельная версия (задание 2)
g++ -fopenmp -O2 -std=c++17 task3.cpp -o task3.exe   # сравнение производительности (задание 3)
```
В Windows PowerShell для задания количества потоков можно использовать:
```bash
$env:OMP_NUM_THREADS = '4'
```

### Запуск программы

Выполните скомпилированный файл:
```bash
.\task1.exe   # для последовательной сортировки
.\task2.exe   # для параллельной сортировки
.\task3.exe   # для сравнения производительности
```
## Итоги:
- Параллельное выполнение улучшает производительность, особенно на больших массивах и при алгоритмах, которые можно распараллелить.
- Сортировка вставками остаётся последовательной из-за зависимости между итерациями.
- Сравнение производительности показывает, что выбор правильного алгоритма и способа параллельного выполнения критически важно для оптимизации времени работы программы.


## Автор проекта  
Студент: Aruzhan Bissimbayeva 

Группа: ADA-2403M

## Преподаватель  
Проверяющий: Sadvakassova Kuralay

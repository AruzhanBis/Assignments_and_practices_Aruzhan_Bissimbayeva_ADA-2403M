// 4. Создать массив из 5 000 000 целых чисел,
    // вычислить среднее значение:
    // 1) последовательно,
    // 2) параллельно с OpenMP + reduction,
    // сравнить время выполнения двух реализаций

    // код для запуска в терминале:
    //        g++ -fopenmp task4.cpp -o task4.exe
    //        .\task4.exe 

#include <iostream>            // подключаем библиотеку для ввода/вывода
#include <cstdlib>             // содержит rand(), srand() для генерации случайных чисел
#include <ctime>               // содержит time(), используем для инициализации случайных чисел
#include <chrono>              // для измерения времени выполнения
#include <omp.h>               // библиотека OpenMP для параллельных вычислений

int main()                     // точка входа программы
{
    const int N = 5000000;     // создаем константу N = размер массива (5 млн элементов)

    int* arr = new int[N];     // выделяем динамическую память под массив целых чисел

    srand(time(nullptr));      // инициализируем генератор случайных чисел текущим временем

    // Заполнение массива случайными числами
    for(int i = 0; i < N; i++)   // цикл по массиву от 0 до N-1
        arr[i] = rand() % 100;   // записываем случайные числа от 0 до 99 в каждый элемент массива


 // Последовательное вычисление среднего значения
    
    auto start_seq = std::chrono::high_resolution_clock::now();  // сохраняем текущее время старта

    long long sumSeq = 0;     // переменная для накопления суммы элементов последовательно

    for(int i = 0; i < N; i++) // проходим последовательно по массиву
        sumSeq += arr[i];     // добавляем элемент массива к сумме

    double avgSeq = (double)sumSeq / N; // вычисляем среднее: сумма / количество элементов

    auto end_seq = std::chrono::high_resolution_clock::now();   // сохраняем время окончания
    std::chrono::duration<double> seq_time = end_seq - start_seq; // вычисляем разницу — длительность выполнения

   
    // Параллельное вычисление среднего (OpenMP + reduction)

    auto start_par = std::chrono::high_resolution_clock::now(); // фиксируем время старта параллельного вычисления

    long long sumPar = 0;     // глобальная сумма, итог будет формироваться через reduction

    #pragma omp parallel for reduction(+:sumPar) // создаем параллельный цикл, суммирование с reduction
    for(int i = 0; i < N; i++)                   // каждый поток получает свою часть массива
        sumPar += arr[i];                        // потоки накапливают суммы независимо, затем reduction объединяет

    double avgPar = (double)sumPar / N;          // вычисление среднего аналогично последовательному случаю

    auto end_par = std::chrono::high_resolution_clock::now();       // фиксируем конец времени
    std::chrono::duration<double> par_time = end_par - start_par;   // длительность выполнения параллельного алгоритма


    // Вывод результатов
    std::cout << "Результаты вычисления среднего значения:" << std::endl;  // общий заголовок

    std::cout << "\nПоследовательный алгоритм:" << std::endl;              // заголовок блока результатов
    std::cout << "Среднее = " << avgSeq << std::endl;                      // вывод среднего последовательного
    std::cout << "Время = " << seq_time.count() << " сек." << std::endl;   // вывод времени выполнения

    std::cout << "\nПараллельный алгоритм OpenMP (reduction):" << std::endl;   // заголовок параллельного поиска
    std::cout << "Среднее = " << avgPar << std::endl;                         // вывод среднего параллельного
    std::cout << "Время = " << par_time.count() << " сек." << std::endl;     // вывод времени выполнения


    //Сравнение времени выполнения двух реализаций

    double speedup = seq_time.count() / par_time.count();          // считаем ускорение

    std::cout << "\nСравнение времени выполнения:" << std::endl;
    std::cout << "Ускорение (speedup) = " << speedup << std::endl; // вывод speedup

    if(seq_time.count() > par_time.count())                        // сравнение кто быстрее
        std::cout << "Вывод: параллельный алгоритм быстрее." << std::endl;
    else if(seq_time.count() < par_time.count())
        std::cout << "Вывод: последовательный алгоритм быстрее." << std::endl;
    else
        std::cout << "Время выполнения одинаковое." << std::endl;

    delete[] arr;           // освобождаем динамически выделенную память под массив

    return 0;               // завершаем программу
}

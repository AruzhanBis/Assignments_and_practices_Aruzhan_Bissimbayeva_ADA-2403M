/* Задание 2. Параллельная реализация сортировок с использованием OpenMP

В данной программе реализованы три классических алгоритма сортировки:
сортировка пузырьком, сортировка выбором и сортировка вставками.
В отличие от первого задания, здесь используются директивы OpenMP для распараллеливания
цикла сравнения элементов или поиска минимума, что позволяет ускорить выполнение на
многопроцессорных системах.

Программа создаёт массивы случайных целых чисел трёх разных размеров
(1000, 10,000, 100,000) и замеряет время выполнения каждой сортировки.
В конце выводится время выполнения для каждой сортировки и каждого размера массива,
что позволяет оценить эффективность параллельного выполнения.
*/

//пример команды для запуска кода:
//g++ -fopenmp -O2 -std=c++17 task2.cpp -o task2.exe
// $env:OMP_NUM_THREADS = '4'        
// .\task2.exe                         

#include <iostream>   // Библиотека ввода/вывода
#include <vector>     // Контейнер vector для хранения массивов
#include <cstdlib>    // Функции rand() и srand()
#include <ctime>      // Для time()
#include <omp.h>      // Для OpenMP (параллельные директивы и измерение времени)

using namespace std;

// Функция для генерации массива случайных чисел
vector<int> generateArray(int size) {       // принимает размер будущего массива
    vector<int> arr(size);                  // создаём вектор заданного размера
    for (int i = 0; i < size; ++i) {        // цикл по всем элементам
        arr[i] = rand() % 100000;           // заполняем случайными числами
    }
    return arr;                             // возвращаем сгенерированный массив
}

// Параллельная сортировка пузырьком
void bubbleSortParallel(vector<int>& arr) { // передаем массив по ссылке
    int n = arr.size();                     // получаем длину массива
    for (int i = 0; i < n - 1; ++i) {       // внешний цикл проходов
        // Параллельный цикл по j
        #pragma omp parallel for            // директива OpenMP для параллельного цикла
        for (int j = 0; j < n - i - 1; ++j) { // внутренний цикл сравнения элементов
            if (arr[j] > arr[j + 1]) {      // сравнение соседних элементов
                swap(arr[j], arr[j + 1]);   // меняем местами
            }
        }
    }
}

// Параллельная сортировка выбором
void selectionSortParallel(vector<int>& arr) { // сортировка выбором параллельно
    int n = arr.size();                     // получаем длину массива
    for (int i = 0; i < n - 1; ++i) {       // внешний цикл проходов
        int minIndex = i;                   // индекс минимального элемента

        // Параллельный поиск минимального элемента
        #pragma omp parallel                // создаём параллельную область
        {
            int localMin = minIndex;        // локальный индекс минимума для потока
            #pragma omp for nowait          // распараллеливаем цикл поиска минимума
            for (int j = i + 1; j < n; ++j) {
                if (arr[j] < arr[localMin]) { // если найден меньший элемент
                    localMin = j;             // сохраняем локальный минимум
                }
            }

            // Секция критического доступа
            #pragma omp critical             // защищаем общий раздел данных
            {
                if (arr[localMin] < arr[minIndex]) { // обновляем общий минимум
                    minIndex = localMin;
                }
            }
        }

        swap(arr[i], arr[minIndex]);        // обмен найденного минимума с текущим
    }
}

// Сортировку вставками сложно полностью распараллелить,
// поэтому параллельный вариант используется частично
void insertionSortParallel(vector<int>& arr) { // передаем массив по ссылке
    int n = arr.size();                     // длина массива
    for (int i = 1; i < n; ++i) {           // проходим по элементам
        int key = arr[i];                   // сохраняем текущий элемент
        int j = i - 1;                      // индекс предыдущего элемента

        // Сдвигаем элементы, пока не найдём место для key
        while (j >= 0 && arr[j] > key) {    // ищем позицию key
            arr[j + 1] = arr[j];            // сдвигаем элемент вправо
            --j;                            // двигаемся назад
        }
        arr[j + 1] = key;                   // вставляем key на нужную позицию
    }
}

int main() {
    srand(time(0));                         // инициализация генератора случайных чисел

    vector<int> sizes = {1000, 10000, 100000}; // размеры массивов для тестов

    for (int size : sizes) {                // цикл по разным размерам массивов
        vector<int> arr = generateArray(size); // генерируем массив

        cout << "\nРазмер массива: " << size << endl; // вывод размера массива

        // Сортировка Пузырьком
        vector<int> arrBubble = arr;        // копия исходного массива
        double start = omp_get_wtime();     // фиксируем время начала
        bubbleSortParallel(arrBubble);      // вызываем параллельную сортировку
        double end = omp_get_wtime();       // фиксируем время завершения
        cout << "Время параллельной сортировки Пузырьком: " << end - start << " сек\n";

        // Сортировка Выбором
        vector<int> arrSelection = arr;     // копия исходного массива
        start = omp_get_wtime();            // фиксируем время начала
        selectionSortParallel(arrSelection);// вызываем параллельную сортировку выбором
        end = omp_get_wtime();              // фиксируем время завершения
        cout << "Время параллельной сортировки Выбором: " << end - start << " сек\n";

        // Сортировка Вставкой
        vector<int> arrInsertion = arr;     // копия исходного массива
        start = omp_get_wtime();            // фиксируем время начала
        insertionSortParallel(arrInsertion);// вызываем сортировку вставками
        end = omp_get_wtime();              // фиксируем время завершения
        cout << "Время сортировки Вставкой (частично параллельный): " << end - start << " сек\n";
    }

    return 0;                               // завершение программы
}

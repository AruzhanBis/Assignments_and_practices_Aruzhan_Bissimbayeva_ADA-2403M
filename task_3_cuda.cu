
// Подключаем необходимые библиотеки
#include <iostream>      // Для стандартного ввода-вывода в консоль
#include <vector>        // Для использования динамического массива std::vector
#include <algorithm>     // Для функции std::swap для обмена значений
#include <cuda_runtime.h> // Основная библиотека CUDA для работы с GPU

// Функция для проверки ошибок CUDA - завершает программу при обнаружении ошибки
void cudaCheck(cudaError_t err, const char* msg) {
    // Проверяем, вернула ли функция CUDA ошибку
    if (err != cudaSuccess) {
        // Выводим сообщение об ошибке в стандартный поток ошибок
        std::cerr << "CUDA Ошибка: " << msg << " - " << cudaGetErrorString(err) << std::endl;
        exit(1);  // Завершаем программу с кодом ошибки 1
    }
}

// 1. Ядро CUDA для операции heapify - восстановление свойства кучи для поддерева
__global__ void heapifyKernel(int* arr, int n, int i) {
    // Каждый поток обрабатывает один узел кучи (корень поддерева)
    int largest = i;          // Инициализируем largest как индекс корня поддерева
    int left = 2 * i + 1;     // Вычисляем индекс левого потомка в массиве-куче
    int right = 2 * i + 2;    // Вычисляем индекс правого потомка в массиве-куче
    
    // Проверяем, существует ли левый потомок и больше ли он текущего наибольшего элемента
    if (left < n && arr[left] > arr[largest]) {
        largest = left;  // Обновляем индекс наибольшего элемента на левого потомка
    }
    
    // Проверяем, существует ли правый потомок и больше ли он текущего наибольшего элемента
    if (right < n && arr[right] > arr[largest]) {
        largest = right;  // Обновляем индекс наибольшего элемента на правого потомка
    }
    
    // Если наибольший элемент не является корнем поддерева
    if (largest != i) {
        // Меняем местами корень с наибольшим элементом
        int temp = arr[i];        // Сохраняем значение корня во временной переменной
        arr[i] = arr[largest];    // Перемещаем наибольший элемент в корень
        arr[largest] = temp;      // Перемещаем старый корень на место наибольшего элемента
        // В реальной реализации здесь была бы рекурсия, но в CUDA это невозможно
    }
}

// 2. Ядро CUDA для параллельного построения максимальной кучи из массива
__global__ void buildMaxHeapKernel(int* arr, int n) {
    // Вычисляем глобальный индекс потока в сетке
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    
    // Проверяем, что индекс находится в пределах размера массива
    if (idx < n) {
        // Вычисляем индекс узла для обработки (обратный порядок от листьев к корню)
        int i = n / 2 - 1 - idx;  // Обратный порядок позволяет параллельно обрабатывать узлы
        
        // Проверяем, что это нелистовой узел (только такие узлы нуждаются в heapify)
        if (i >= 0) {
            int largest = i;      // Предполагаем, что корень - наибольший элемент
            int left = 2 * i + 1; // Вычисляем индекс левого потомка
            int right = 2 * i + 2; // Вычисляем индекс правого потомка
            
            // Сравниваем корень с левым потомком, если он существует
            if (left < n && arr[left] > arr[largest]) {
                largest = left;  // Обновляем индекс наибольшего элемента
            }
            
            // Сравниваем текущий наибольший с правым потомком, если он существует
            if (right < n && arr[right] > arr[largest]) {
                largest = right;  // Обновляем индекс наибольшего элемента
            }
            
            // Если наибольший элемент не является корнем
            if (largest != i) {
                // Выполняем обмен корня с наибольшим элементом
                int temp = arr[i];        // Сохраняем значение корня
                arr[i] = arr[largest];    // Перемещаем наибольший в корень
                arr[largest] = temp;      // Перемещаем старый корень
            }
        }
    }
}

// 3. Ядро CUDA для параллельного извлечения максимального элемента (корня кучи)
__global__ void extractMaxKernel(int* arr, int n, int heap_size, int* sorted_part) {
    // Номер блока определяет, какой элемент извлекается (в упрощенной версии только блок 0)
    int block_id = blockIdx.x;
    
    // В этой версии только первый блок потоков выполняет извлечение
    if (block_id == 0) {
        // Только первый поток в блоке выполняет операции с корнем кучи
        if (threadIdx.x == 0) {
            // Извлекаем максимальный элемент (корень кучи) в конец отсортированной части
            sorted_part[heap_size] = arr[0];
            // Заменяем корень кучи последним элементом кучи
            arr[0] = arr[heap_size - 1];
        }
        // Синхронизируем все потоки в блоке перед продолжением
        __syncthreads();
        
        // Только потоки, соответствующие нелистовым узлам, участвуют в восстановлении кучи
        if (threadIdx.x < heap_size / 2) {
            int i = 0;  // Начинаем восстановление кучи с корня
            // Итеративно восстанавливаем свойство кучи (просеивание вниз)
            while (true) {
                int largest = i;        // Предполагаем, что текущий узел - наибольший
                int left = 2 * i + 1;   // Индекс левого потомка
                int right = 2 * i + 2;  // Индекс правого потомка
                
                // Сравниваем с левым потомком (если он существует в уменьшенной куче)
                if (left < heap_size - 1 && arr[left] > arr[largest]) {
                    largest = left;  // Левый потомок больше
                }
                
                // Сравниваем с правым потомком (если он существует в уменьшенной куче)
                if (right < heap_size - 1 && arr[right] > arr[largest]) {
                    largest = right;  // Правый потомок больше
                }
                
                // Если наибольший элемент не является текущим узлом
                if (largest != i) {
                    // Меняем местами текущий узел с наибольшим потомком
                    int temp = arr[i];
                    arr[i] = arr[largest];
                    arr[largest] = temp;
                    // Продолжаем просеивание с новой позиции
                    i = largest;
                } else {
                    // Свойство кучи восстановлено, выходим из цикла
                    break;
                }
            }
        }
    }
}

// 4. Функция для пирамидальной сортировки на CPU (для маленьких массивов)
void heapSortCPU(std::vector<int>& arr) {
    int n = arr.size();  // Получаем размер массива
    
    // 1. Построение максимальной кучи из массива
    for (int i = n / 2 - 1; i >= 0; i--) {
        int largest = i;      // Корень текущего поддерева
        int left = 2 * i + 1; // Индекс левого потомка
        int right = 2 * i + 2; // Индекс правого потомка
        
        // Сравниваем корень с левым потомком
        if (left < n && arr[left] > arr[largest]) {
            largest = left;  // Левый потомок больше
        }
        
        // Сравниваем с правым потомком
        if (right < n && arr[right] > arr[largest]) {
            largest = right;  // Правый потомок больше
        }
        
        // Если наибольший элемент не является корнем
        if (largest != i) {
            // Меняем местами корень с наибольшим элементом
            std::swap(arr[i], arr[largest]);
            
            // Итеративно восстанавливаем свойство кучи для измененного поддерева
            int j = largest;
            while (j <= n / 2 - 1) {
                int new_largest = j;
                int new_left = 2 * j + 1;
                int new_right = 2 * j + 2;
                
                // Сравниваем с левым потомком
                if (new_left < n && arr[new_left] > arr[new_largest]) {
                    new_largest = new_left;
                }
                // Сравниваем с правым потомком
                if (new_right < n && arr[new_right] > arr[new_largest]) {
                    new_largest = new_right;
                }
                
                // Если нашли больший элемент в потомках
                if (new_largest != j) {
                    std::swap(arr[j], arr[new_largest]);
                    j = new_largest;  // Продолжаем просеивание вниз
                } else {
                    break;  // Свойство кучи восстановлено
                }
            }
        }
    }
    
    // 2. Извлечение элементов из кучи один за другим
    for (int i = n - 1; i > 0; i--) {
        // Перемещаем текущий корень (максимальный элемент) в конец массива
        std::swap(arr[0], arr[i]);
        
        // Восстанавливаем свойство кучи для уменьшенной кучи
        int heap_size = i;  // Новый размер кучи
        int j = 0;          // Начинаем с корня
        
        // Итеративно восстанавливаем кучу (просеивание вниз)
        while (true) {
            int largest = j;        // Предполагаем, что текущий узел - наибольший
            int left = 2 * j + 1;   // Индекс левого потомка
            int right = 2 * j + 2;  // Индекс правого потомка
            
            // Сравниваем с левым потомком
            if (left < heap_size && arr[left] > arr[largest]) {
                largest = left;
            }
            // Сравниваем с правым потомком
            if (right < heap_size && arr[right] > arr[largest]) {
                largest = right;
            }
            
            // Если нашли больший элемент в потомках
            if (largest != j) {
                std::swap(arr[j], arr[largest]);
                j = largest;  // Продолжаем просеивание вниз
            } else {
                break;  // Свойство кучи восстановлено
            }
        }
    }
}

// 5. Основная функция параллельной пирамидальной сортировки на CUDA
void parallelHeapSortCUDA(std::vector<int>& arr) {
    int n = arr.size();  // Получаем размер массива
    
    // Если массив пустой или состоит из одного элемента, ничего не делаем
    if (n <= 1) return;
    
    // Если массив маленький (меньше или равен 32 элементам), сортируем на CPU
    if (n <= 32) {
        heapSortCPU(arr);  // Вызываем CPU версию сортировки
        return;           // Выходим из функции
    }
    
    // Объявляем указатели для памяти на GPU
    int* d_arr;           // Указатель на основной массив в памяти GPU
    int* d_sorted;        // Указатель на массив для отсортированных элементов
    int* d_temp;          // Указатель на временный массив
    
    // Выделяем память на GPU для основного массива
    cudaCheck(cudaMalloc(&d_arr, n * sizeof(int)), "cudaMalloc d_arr");
    // Выделяем память для массива отсортированных элементов
    cudaCheck(cudaMalloc(&d_sorted, n * sizeof(int)), "cudaMalloc d_sorted");
    // Выделяем память для временного массива
    cudaCheck(cudaMalloc(&d_temp, n * sizeof(int)), "cudaMalloc d_temp");
    
    // Копируем данные из оперативной памяти (CPU) в память GPU
    cudaCheck(cudaMemcpy(d_arr, arr.data(), n * sizeof(int), cudaMemcpyHostToDevice), "Копирование на GPU");
    
    // Выводим информационное сообщение о начале сортировки
    std::cout << "Запуск параллельной пирамидальной сортировки на CUDA..." << std::endl;
    std::cout << "Размер массива: " << n << " элементов" << std::endl;
    
    // Этап 1: Параллельное построение максимальной кучи
    std::cout << "Этап 1: Параллельное построение максимальной кучи..." << std::endl;
    
    // Настраиваем параметры запуска ядер CUDA
    int threads = 256;  // Количество потоков в одном блоке (стандартное значение)
    int blocks = (n + threads - 1) / threads;  // Вычисляем необходимое количество блоков
    
    // Запускаем ядро построения кучи несколько раз для полного построения
    for (int i = 0; i < 3; i++) {
        buildMaxHeapKernel<<<blocks, threads>>>(d_arr, n);
        cudaCheck(cudaGetLastError(), "buildMaxHeapKernel");
        cudaDeviceSynchronize();  // Ждем завершения всех потоков
    }
    
    // Этап 2: Параллельное извлечение элементов из кучи
    std::cout << "Этап 2: Параллельное извлечение элементов из кучи..." << std::endl;
    
    // Для каждого элемента извлекаем максимум и уменьшаем кучу
    for (int heap_size = n; heap_size > 1; heap_size--) {
        // Запускаем ядро для извлечения максимального элемента
        extractMaxKernel<<<1, threads>>>(d_arr, n, heap_size, d_sorted);
        cudaCheck(cudaGetLastError(), "extractMaxKernel");
        cudaDeviceSynchronize();  // Ждем завершения
        
        // После каждого извлечения нужно восстановить кучу
        if (heap_size > 2) {
            // Создаем временный вектор на CPU для текущего состояния кучи
            std::vector<int> current_heap(heap_size - 1);
            
            // Копируем текущее состояние кучи из GPU в CPU
            cudaCheck(cudaMemcpy(current_heap.data(), d_arr, (heap_size - 1) * sizeof(int), 
                      cudaMemcpyDeviceToHost), "Копирование для восстановления кучи");
            
            // Восстанавливаем свойство кучи на CPU
            int i = 0;
            while (i <= (heap_size - 2) / 2) {
                int largest = i;
                int left = 2 * i + 1;
                int right = 2 * i + 2;
                
                // Сравниваем с левым потомком
                if (left < heap_size - 1 && current_heap[left] > current_heap[largest]) {
                    largest = left;
                }
                // Сравниваем с правым потомком
                if (right < heap_size - 1 && current_heap[right] > current_heap[largest]) {
                    largest = right;
                }
                
                // Если нашли больший элемент в потомках
                if (largest != i) {
                    std::swap(current_heap[i], current_heap[largest]);
                    i = largest;  // Продолжаем просеивание вниз
                } else {
                    break;  // Свойство кучи восстановлено
                }
            }
            
            // Копируем восстановленную кучу обратно на GPU
            cudaCheck(cudaMemcpy(d_arr, current_heap.data(), (heap_size - 1) * sizeof(int), 
                      cudaMemcpyHostToDevice), "Копирование восстановленной кучи");
        }
    }
    
    // Копируем отсортированный массив из памяти GPU обратно в память CPU
    cudaCheck(cudaMemcpy(arr.data(), d_sorted, n * sizeof(int), cudaMemcpyDeviceToHost), 
              "Копирование отсортированного массива");
    
    // Освобождаем память GPU (важно делать это для предотвращения утечек памяти)
    cudaCheck(cudaFree(d_arr), "cudaFree d_arr");
    cudaCheck(cudaFree(d_sorted), "cudaFree d_sorted");
    cudaCheck(cudaFree(d_temp), "cudaFree d_temp");
    
    // Выводим сообщение об успешном завершении сортировки
    std::cout << "Параллельная пирамидальная сортировка завершена." << std::endl;
}

// 6. Функция для проверки правильности сортировки массива
bool checkSorted(const std::vector<int>& arr) {
    // Проходим по массиву и проверяем, что каждый следующий элемент не меньше предыдущего
    for (size_t i = 1; i < arr.size(); i++) {
        // Если найден элемент меньше предыдущего, массив не отсортирован
        if (arr[i] < arr[i - 1]) {
            // Выводим информацию об ошибке
            std::cout << "Найдена ошибка: " << arr[i-1] << " > " << arr[i] 
                      << " (позиции " << i-1 << " и " << i << ")" << std::endl;
            return false;  // Возвращаем false - массив не отсортирован
        }
    }
    return true;  // Все элементы в правильном порядке, возвращаем true
}

// 7. Главная функция программы - точка входа
int main() {
    // Выводим заголовок программы
    std::cout << "Параллельная пирамидальная сортировка на CUDA" << std::endl;
        
    // Создаем тестовый массив из 16 элементов
    std::vector<int> array = {38, 27, 43, 3, 9, 82, 10, 15, 7, 22, 56, 41, 18, 33, 29, 5};
    
    // Выводим исходный массив
    std::cout << "\nИсходный массив:" << std::endl;
    for (int i = 0; i < array.size(); i++) {
        std::cout << array[i] << " ";  // Выводим каждый элемент через пробел
    }
    std::cout << std::endl;  // Переход на новую строку
    
    // Запускаем параллельную пирамидальную сортировку на CUDA
    parallelHeapSortCUDA(array);
    
    // Выводим отсортированный массив
    std::cout << "\nОтсортированный массив:" << std::endl;
    for (int i = 0; i < array.size(); i++) {
        std::cout << array[i] << " ";
    }
    std::cout << std::endl;
    
    // Проверяем корректность сортировки
    std::cout << "\nПроверка сортировки: ";
    if (checkSorted(array)) {
        std::cout << "Массив корректно отсортирован!" << std::endl;
    } else {
        std::cout << "Массив не отсортирован." << std::endl;
    }
    
    // Завершение программы с выводом финального сообщения
    std::cout << "Программа выполнена успешно." << std::endl;
    
    return 0;  // Возвращаем 0 - признак успешного завершения программы
}
